# 第7章 パフォーマンスチューニングとプロファイリング

## 7.1 ベンチマーク基盤の構築
最適化の第一歩は再現性のあるベンチマーク環境を整えることだ。ベンチ対象の端末やOSバージョン、BSP、ドライバを固定し、CPU/GPUのスケーリング設定を一定に保つ。ncnn付属の`benchncnn`は代表的なレイヤーやモデルを測定でき、`--loop`オプションで複数回の平均を取得してばらつきを抑える。CIパイプラインではベンチ結果を自動収集し、時系列で可視化することで性能劣化を検知する。

## 7.2 レイヤー単位のプロファイリング
`ncnn::Option::use_shader_pack8`などの最適化を切り替えつつ、レイヤー別の処理時間を確認するために`ncnn::Profiler`を利用する。`Extractor::set_profiling(true)`を呼ぶと、推論完了後に各レイヤーの実行時間がログ出力され、ボトルネックの特定が容易になる。さらにVulkan有効時には`VK_EXT_debug_utils`を活用してGPU側のタイムスタンプを取得し、CPU/GPUの同期ポイントを突き止める。

## 7.3 CPU最適化のテクニック
CPUパフォーマンスを引き出すには、命令レベル並列性とメモリアクセス効率を高める。ncnnはWinograd畳み込みや`im2col + GEMM`など複数の実装を持つため、`Option`で切り替えて比較する。キャッシュヒット率を高めるために`opt.use_packing_layout = true`を有効化し、SIMDベクトル幅に合わせたパッキングを行う。ARM big.LITTLE構成では、大核・小核へのスレッド割り当てを`taskset`で制御し、バックグラウンドタスクと競合しないようにする。x86の場合は`perf`や`VTune`でマイクロアーキテクチャ統計を取り、パイプラインストールやメモリボトルネックを可視化する。

## 7.4 GPU最適化のポイント
Vulkanパスの性能はバッファ転送とシェーダー効率に左右される。入力・出力の`Mat`をGPU上に維持し、不要なCPU-GPUコピーを削減する。シェーダーのローカルメモリ使用量を分析し、ワークグループサイズを`vkSpecializationConstant`で調整する。GPUプロファイラ（Adreno Profiler、Mali Graphics Debugger、RenderDocなど）を利用し、GPU負荷の偏りやバリアの最適化余地を探る。FP16計算を許可すると帯域消費が大幅に減るため、精度要件を満たす範囲で少数点精度を下げる。

## 7.5 メモリ帯域とキャッシュの最適化
メモリ帯域は多くの推論ワークロードのボトルネックであり、`ncnnoptimize`でレイヤー融合を進めることでロード回数を減らせる。`Mat::create`時に行列のストライドを意識し、チャンネル優先（NC1HWC4）などのメモリレイアウトが有効なケースではカスタムレイヤーを導入する。キャッシュ行を超えるアクセスが頻発する場合は、`opt.blob_allocator`の設定を見直して、サイズの近いバッファを同じアロケータにまとめるといった手法もある。

## 7.6 ヒートマップ解析と実機テスト
アプリ統合後は、リアルユーザーの動作ログを「ヒートマップ」として収集し、平均レイテンシやメモリ使用量を観測する。Androidでは`android.os.Trace`、iOSでは`Signpost`を組み合わせ、推論開始・終了イベントを記録する。実機テストではサーマルスロットリングが発生するかを監視し、長時間連続推論時の挙動を確認する。負荷テスト環境では複数端末に同時配信し、ネットワークやセンサー入力を模擬することで現実的なシナリオを再現する。

## 7.7 フィードバックループの構築
チューニング結果を開発チームに還元するため、ベンチマーク・プロファイル・実機ログを統合したダッシュボードを整備する。モデル更新やアプリリリースごとに自動でベンチ結果を比較し、性能劣化が検出された場合はアラートを発する。定期的な性能レビュー会議を設け、各デバイスのボトルネックと対策状況を共有することで改善サイクルが途切れないようにする。

## 7.8 本章のまとめ
本章ではパフォーマンスチューニングとプロファイリングに必要な手法を整理した。ベンチマーク基盤、CPU/GPUの最適化、メモリ帯域改善、ヒートマップ解析、フィードバック体制を組み合わせることで、ncnnアプリの性能を継続的に向上させる仕組みを構築できる。次章ではカスタムレイヤーの実装に焦点を当て、特殊な演算要求に対応する方法を紹介する。
